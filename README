Task:
- Need to write minls and minget so that I can get data out of the Minix filesystem whilst being outside of the 
  minix filesystem
- Minget: has to parse through all the inodes and directory entries to to list all files and directories
- Minls: has to follow zone pointers to find where the data block is and retreive that data

How to break it up conceptually:
- Printing File: handles all the output and formatting
    - will deal with printing different stuff for the flags (-v -p)
- Common Helper File: includes common parsing functions
    - parsing partition table
        - tells me where the filesystem starts on the disk image
        - need this to locate the superblock 
    - reading superblock
        - tells me the size of each block
        - how many blocks are in each zone
        - total i-nodes
        - total zones
        - zone number where the datazone starts
        - the type of file system (magic number)
    - locating inodes and zones
        - tells me the type of the file and its permissions
        - the size of the file
        - pointers to the data zones
        - INODES ARE NUMBERED STARTING 1 NOT 0 !!!
    - endianess 
        - macos M1 is big endian? and minix is little endian so need to make sure it works to parse through minix
    - traversing directory entries
        - directory etnries map filenames to i-nodes
        - use that to traverse through and find the next file 
        - or use that to find the i-node of the file to copy and then go to the zone with its data
- Minget
    - parse through all the valid command line arguments 
    - traverse the direcories and find the block
    - read the file
    - deal with holes and empty zones 
    - write to stdout
- Minls
    - parse all the valid command line arguments
    - traverse through directoreis 
    - know the type of the files and directories through i-node info
    - print out the formatted strings to stdout

    Minix File System Understanding:
    - the partition holds the data
    - the superblock holds how many blocks per zone, how many inodes, and how many zones
    - the inode table holds info about all the inodes, each inode holds file metadata
    - the inode also holds zone pointers
    - a zone is the actual spot where the data of the file is
    - there are 7 direct zones given by default
    - if your data doesnt fit within the direct zones, you use indirect zones
    - the indirect zone points to an indirect zone table, that holds addresses of the actual indirect zones
    - follow the pointer to get the rest of the data
    * since directories are special files, use this same process to read directories * 
        - however, the zones will not hold data, but will hold directory entries which include the inode humber and the name of the file
        - since a directory is like a folder and can hold many files, the i-node represents the directory as a whole
        - then the inode points to zones, and each zone holds more directory entries, or more info about the files within it

Functions planning to write: 
- Printing:
    - print_partition_table
    - print_superblockyte 
    - print_inode
    - print_directory_list
- Helpers:
    - get_partition_table
        - will first find the partition and subpartition if given, and then read the data out into the partition struct 
        - will include checks to make sure that the partition is valid by checking its signature (0x55 in byte 510 and 0xAA in byte 511)) 
            - check_parition
            - check_partition_table
    - get_superblock
        - gets all the metadata about the filesystem out and stores it into the superblock struct
        - includes similar checks to see if the superblock is valid 
    - get_inodes
        - will get all the inodes out of the inode table and store their info in inode structs
    - get_directory
        - will read the full inode and follow pointers into the zones to store all the directory entries
        - will save that all into an array of directory structs. 
    - fill_directory 
        - get the directory contents and fill them in the directory struct
    - get_directory_inode
        - goes through the given path until it gets to the inode it is looking for
        - it traverses the path and gets all the directory entries from the current directory
        - stores that in an array of entries 
        - then it updates how many directory entries we have just put in there by dividing the total size of the node by how much space a directory entry takes up
        - this tells us how many entries are in that inode
        - then it goes through that list of directory entries and compares it with the path name given
        - if it matches, then it goes further down this path and gets the next inode in the path
        - then we do the same thing for the next inode filled with directory entries until the path is fully searched
        - if the path is empty at the very end it returns the last inode of the last thing in the path
    - read_file
        - for minget, once we find the file we have to read the contents out
        - might have to read from indirect blocks, then direct blocks depending on how large the file is
        - need to know how far into the indirect block the info is from the offset
        - will read the data out into a buffer
        - will use this global buffer to print the contents of the file later
    - parse_command_line (use getopt)
        - 
    - read_superblock (copy all data of that into a struct)

- Minls:
    - main (argv, argc)
    - parse through the command line arguments
    - open the disk image file
    - find the correct partition or sub partition
    - read the superblock and make sure its of minix type
    - follow that path all the way down to the directory 
    - get every directory entry out of that inode
    - print all of those out in the right format 
- Minget:
    - main (argv, argc)
    - parse through the command line arguments again
    - also open the disk image
    - find the correct partition or subpartition
    - find the superblock 
    - traverse down the path to get to the file
    - read all the contents out of the file into the buffer
    - print out the buffer

Printing Functions:




stuff left: 
printing functions re-write
the parsing command line write with if else statements 
then debug 
change readme names